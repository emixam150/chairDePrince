var app = require('./app.js');

global.isload = 0; //0:no load,1:loaded,2:loading

function lancement(req,res,srv,body){
    if(isload == 1){
	app.start(req, res, srv, body);
    }else if(isload == 0){
	isload = 2;
	var next = function(){isload = 1;
			      console.log('ressources loaded');
			      app.start(req, res, srv,body);
			     };
	app.load(next);
    }else{
	res.end('Wait please and retry');
    }

}

exports.run = function(req, res, srv, ioServer) {
    //on s'occupe des methodes POST
    if(req.method == 'POST'){
	var body = '';
	req.on('data', function(data) {
	    body += data;
	    if(body.length > 1e6) {
		body = '';
		res.writeHead(413, {'Content-Type': 'text/plain'});
		res.end();
		req.connection.destroy();
	    }
	});
	req.on('end',function(){
	    lancement(req,res,srv,body);
	});
    }else {
	lancement(req,res,srv,null);
    }
};


/*
 * Socket IO
 */

var paths = require($.paths),
tempModel = require(paths.models + '/template.js'),
MathOb = require(paths.models + '/math.js'),
fs = require('fs');
var listMath = [];
exports.execSocket= function(socket){


    var currentMath = null,
    currentIntervalMath = null,
    htmlMath = '',
    mathEltDisplay = require(paths.controllers + '/math/math-elt-display.js');
    
    socket.on('math',function(){

	fs.readFile(paths.html +'/math/math-elt.html','utf8',function(err, data){
	    if(err) throw err;
	    htmlMath = data
	});
	//socket.on('endMath', function(){console.log('end');});

	//listage des éléments mathématiques
	var MathUseList = new MathOb();
	MathUseList.find({},function(listOfElt){
	    var listOfMath = [],
	    cpt = 0;
	    for(var elt in listOfElt){
		if( typeof listOfElt[elt].content.title != 'undefined'){
		    listOfMath.push({name: listOfElt[elt].name,
				     title: listOfElt[elt].content.title});
		}
		cpt++;
		if(cpt == listOfElt.length)
		    socket.emit('math',listOfMath);
	    }
	    if(listOfElt.length == 0)
		socket.emit('math',listOfMath);
	});
	//mise en place de la connexion
	socket.on('newTitleMath', function(title){
	    currentMath = new MathOb(title);
	    currentMath.addThis(function(result){
		if(typeof result != 'undefined'){
		    socket.emit('newContentMath', currentMath.content);
		}else{
		    currentMath = null;
		    socket.emit('mathWarning','Warning: Name already used');
		}
	    });
	});
	
	socket.on('loadNameMath', function(name){
	    currentMath = new MathOb();
	    currentMath.getByName(name, function(result){
		if(typeof result != 'undefined'){
		    socket.emit('newContentMath', currentMath.content);
		}else{
		    currentMath = null;
		    socket.emit('mathWarning', 'Warning: Name don\'t exists');
		}
	    });
	});

	socket.on('refreshMath',function(content){

	    //mise à jour des fils
	    updateChildren(currentMath, content, function(){
		//mise à jour dans la base de donnée
		currentMath.content = content;
		currentMath.updateThis(currentMath.content);
		// creation du rendu html
		var mathToWork = clone(currentMath);
		mathEltDisplay.exec(mathToWork, htmlMath, function(section){
		fs.readFile(paths.html +'/template/figure.html',function(err, figTemp){
		    if(err) throw err;
		    completContent(mathToWork.content.tree, 'figure', figTemp.toString(), function(){
			tempModel.constructOutput(section, function(output){
			    socket.emit('refreshMath',output);
			});
		    });
		});
	    });
	    });

	});
    });

    socket.on('listOfMath',function(){
	currentMath.find({},function(listOfElt){
	    var listOfMath = [],
	    cpt = 0;
	    for(var elt in listOfElt){
		if( String(listOfElt[elt]._id) != String(currentMath._id)
		    && typeof listOfElt[elt].content.title != 'undefined'){
		    listOfMath.push({name: listOfElt[elt].name,
				     title: listOfElt[elt].content.title});
		}
		cpt++;
		if(cpt == listOfElt.length)
		    socket.emit('listOfMath',listOfMath);
	    }
	});
    });


    socket.on('removeParentMath',function(parentName){
	var parentToUp = new MathOb();
	parentToUp.getByName(parentName, function(result){
	    if(typeof result != 'undefined'){
		if(typeof parentToUp.content.children != 'undefined'){
		    if(parentToUp.content.children.indexOf(currentMath.name) != -1){
			parentToUp.content.children.splice(parentToUp.content.children.indexOf(currentMath.name),1);
			parentToUp.updateThis(parentToUp.content);
			
		    }else{
			console.log('truc chelou');
		    }
		}else{
		    parentToUp.content.children = new Array(currentMath.name);
		    parentToUp.updateThis(parentToUp.content);
		}
	    }else{
		socket.emit('mathWarning', 'deleting impossible : parent '+parent+' do\'nt exist'); 
	    }
	});
    });

    var completContent = function(tree, type, content, cb){
	if(tree.type == type)
	    tree.content = content;
	var nbChildren = tree.children.length,
	indexChildren = 0;
	for(var child in tree.children){
	    completContent(tree.children[child], type, content, function(){
		indexChildren ++;
		if(nbChildren == indexChildren)
		    cb();
	    });
	}
	if(nbChildren == 0)
	    cb();
    };

    updateChildren = function(currentMath, content, cb){
	if(content.parents.length == 0)
	    cb();
	
	var cpt = 0;
	
	function next(){
	    cpt++;
	    if(cpt == content.parents.length)
		cb();
	}
	
	content.parents.forEach(function(parent){
	    if((typeof currentMath.content.parents != 'undefined' && currentMath.content.parents.indexOf(parent) == -1) || typeof currentMath.content.parents == 'undefined'){
		var parentToUp  = new MathOb(); 
		parentToUp.getByName(parent, function(result){ 
		    if(typeof result != 'undefined'){
			if(typeof parentToUp.content.children != 'undefined'){
			    if(parentToUp.content.children.indexOf(currentMath.name) == -1){
				console.log('add: ', parent,parentToUp.content.children);
				parentToUp.content.children.push(currentMath.name);
				parentToUp.updateThis(parentToUp.content);
				next();
			    }else{
				console.log('truc chelou');
				next();}
			}else{
			    console.log('new: ', parent);
			    parentToUp.content.children = new Array(currentMath.name);
			    parentToUp.updateThis(parentToUp.content);
			    next();}
		    }else{
			socket.emit('mathWarning', 'parent '+parent+' do\'nt exist'); 
			next();
		    }
		});
	    }else
		next();
	});
	
    }

// Browser of Math

    socket.on('graphMath', function(){
	var MathBrowser = new MathOb(),
	limitSize = 100;

	MathBrowser.findSort(null, { _id: 1 } ,limitSize, function(docs){
	    
	    constructGraphObject(docs, function(graphObject){
		socket.emit('dataGraphMath',graphObject);
	    }); //end of constructGraphObjet
	}); //end of MathOb.findSort
    }); //end of onGraphMath

}//end of socket function


function constructGraphObject(docs, cb){
    var graphObject ={
	nodes: [],
	edges:[]
    },
    cpt= 0,
    mathStyle = new MathOb();


    docs.forEach(function(mathElt){
	graphObject.nodes.push({
	    id: mathElt.name,
	    label: mathElt.content.title,
	    x: Math.random(),
	    y: Math.random(),
	    size: (typeof mathElt.content.children != 'undefined')? mathElt.content.children.length+1:1,
	    color: mathStyle.translateTypeColor(mathElt.content.type)
	});
	if(typeof mathElt.content.children != 'undefined'){
	    var subcpt = 0;
	    mathElt.content.children.forEach(function(childName){
		graphObject.edges.push({
		    id: childName +'-'+ mathElt.name,
		    source : childName,
		    target: mathElt.name,
		    size: 1,
		    color: mathStyle.translateTypeColor(mathElt.content.type)
		});
		subcpt ++;
		if(mathElt.content.children.length == subcpt)
		    next();
	    }); // end of forEach children

	    if(mathElt.content.children.length == 0)
		next();
	}// end of if children
	else
	    next();
    }); // end of forEach docs
    
    function next(){
	cpt ++;
	if(cpt == docs.length)
	    cb(graphObject);
    }
    if(docs.length == 0)
	cb(graphObject);
};

function clone(obj) {
    // Handle the 3 simple types, and null or undefined
    if (null == obj || "object" != typeof obj) return obj;

    // Handle Date
    if (obj instanceof Date) {
	var copy = new Date();
	copy.setTime(obj.getTime());
	return copy;
    }

    // Handle Array
    if (obj instanceof Array) {
	var copy = [];
	for (var i = 0, len = obj.length; i < len; i++) {
	    copy[i] = clone(obj[i]);
	}
	return copy;
    }

    // Handle Object
    if (obj instanceof Object) {
	var copy = {};
	for (var attr in obj) {
	    if (obj.hasOwnProperty(attr)) copy[attr] = clone(obj[attr]);
	}
	return copy;
    }

    throw new Error("Unable to copy obj! Its type isn't supported.");
}